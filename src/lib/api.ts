import { supabase } from "@/integrations/supabase/client";
import {
  DreamLog,
  SleepLog,
  World,
  Entity,
  SystemModule,
  ThreatEntry,
} from "@/types/dream";

async function getCurrentUserId(): Promise<string | null> {
  const { data: { user } } = await supabase.auth.getUser();
  return user?.id ?? null;
}

// Dream Logs
export async function getDreamLogs(): Promise<DreamLog[]> {
  const { data, error } = await supabase
    .from("dream_logs")
    .select(
      `
      *,
      world:worlds(id, name),
      entities:dream_log_entities(entity:entities(id, name))
    `,
    )
    .order("date", { ascending: false });

  if (error) {
    console.error("Error fetching dream logs:", error);
    return [];
  }

  return (data || []).map((log) => ({
    id: log.dream_id,
    date: log.date,
    wakeTime: log.wake_time,
    world: log.world?.name || "",
    timeSystem: log.time_system as DreamLog["timeSystem"],
    environments: log.environments || [],
    entities:
      log.entities
        ?.map((e: { entity: { name: string } }) => e.entity?.name)
        .filter(Boolean) || [],
    threatLevel: log.threat_level as DreamLog["threatLevel"],
    safetyOverride: log.safety_override as DreamLog["safetyOverride"],
    exit: log.exit as DreamLog["exit"],
    notes: log.notes || undefined,
    createdAt: log.created_at,
  }));
}

export async function addDreamLog(
  log: Omit<DreamLog, "id" | "createdAt">,
): Promise<DreamLog | null> {
  // First, get or create world
  let worldId: string | null = null;
  if (log.world) {
    const { data: existingWorld } = await supabase
      .from("worlds")
      .select("id")
      .eq("name", log.world)
      .maybeSingle();

    if (existingWorld) {
      worldId = existingWorld.id;
    } else {
      const userId = await getCurrentUserId();
      const { data: newWorld } = await supabase
        .from("worlds")
        .insert({ name: log.world, type: "transient", stability: 3, user_id: userId })
        .select("id")
        .single();
      worldId = newWorld?.id || null;
    }
  }

  const userId = await getCurrentUserId();
  // Insert dream log - dream_id is generated by trigger but we provide placeholder
  const { data: newLog, error } = await supabase
    .from("dream_logs")
    .insert({
      dream_id: "", // Will be generated by trigger
      date: log.date,
      wake_time: log.wakeTime,
      world_id: worldId,
      time_system: log.timeSystem,
      environments: log.environments,
      threat_level: log.threatLevel,
      safety_override: log.safetyOverride,
      exit: log.exit,
      notes: log.notes,
      user_id: userId,
    })
    .select()
    .single();

  if (error || !newLog) {
    console.error("Error adding dream log:", error);
    return null;
  }

  // Add entities
  for (const entityName of log.entities) {
    let entityId: string;
    const { data: existingEntity } = await supabase
      .from("entities")
      .select("id")
      .eq("name", entityName)
      .maybeSingle();

    if (existingEntity) {
      entityId = existingEntity.id;
    } else {
      const { data: newEntity } = await supabase
        .from("entities")
        .insert({ name: entityName, role: "observer", user_id: userId })
        .select("id")
        .single();
      entityId = newEntity?.id || "";
    }

    if (entityId) {
      await supabase
        .from("dream_log_entities")
        .insert({ dream_log_id: newLog.id, entity_id: entityId });
    }
  }

  return {
    id: newLog.dream_id,
    date: newLog.date,
    wakeTime: newLog.wake_time,
    world: log.world,
    timeSystem: newLog.time_system as DreamLog["timeSystem"],
    environments: newLog.environments || [],
    entities: log.entities,
    threatLevel: newLog.threat_level as DreamLog["threatLevel"],
    safetyOverride: newLog.safety_override as DreamLog["safetyOverride"],
    exit: newLog.exit as DreamLog["exit"],
    notes: newLog.notes || undefined,
    createdAt: newLog.created_at,
  };
}

export async function updateDreamLog(
  dreamId: string,
  updates: Partial<Omit<DreamLog, "id" | "createdAt">>,
): Promise<DreamLog | null> {
  // Get current dream log first
  const { data: currentLog } = await supabase
    .from("dream_logs")
    .select("*")
    .eq("dream_id", dreamId)
    .single();

  if (!currentLog) return null;

  // Update world if changed
  let worldId = currentLog.world_id;
  if (updates.world) {
    const { data: existingWorld } = await supabase
      .from("worlds")
      .select("id")
      .eq("name", updates.world)
      .maybeSingle();

    if (existingWorld) {
      worldId = existingWorld.id;
    } else {
      const userId = await getCurrentUserId();
      const { data: newWorld } = await supabase
        .from("worlds")
        .insert({ name: updates.world, type: "transient", stability: 3, user_id: userId })
        .select("id")
        .single();
      worldId = newWorld?.id || worldId;
    }
  }

  // Update dream log
  const { data: updatedLog, error } = await supabase
    .from("dream_logs")
    .update({
      world_id: worldId,
      time_system: updates.timeSystem || currentLog.time_system,
      environments: updates.environments || currentLog.environments,
      threat_level:
        updates.threatLevel !== undefined
          ? updates.threatLevel
          : currentLog.threat_level,
      safety_override: updates.safetyOverride || currentLog.safety_override,
      exit: updates.exit || currentLog.exit,
      notes: updates.notes !== undefined ? updates.notes : currentLog.notes,
    })
    .eq("dream_id", dreamId)
    .select()
    .single();

  if (error || !updatedLog) {
    console.error("Error updating dream log:", error);
    return null;
  }

  // Update entities if changed
  if (updates.entities) {
    // Delete existing entity associations
    await supabase
      .from("dream_log_entities")
      .delete()
      .eq("dream_log_id", updatedLog.id);

    // Add new entities
    for (const entityName of updates.entities) {
      let entityId: string;
      const { data: existingEntity } = await supabase
        .from("entities")
        .select("id")
        .eq("name", entityName)
        .maybeSingle();

      if (existingEntity) {
        entityId = existingEntity.id;
      } else {
        const userId = await getCurrentUserId();
        const { data: newEntity } = await supabase
          .from("entities")
          .insert({ name: entityName, role: "observer", user_id: userId })
          .select("id")
          .single();
        entityId = newEntity?.id || "";
      }

      if (entityId) {
        await supabase
          .from("dream_log_entities")
          .insert({ dream_log_id: updatedLog.id, entity_id: entityId });
      }
    }
  }

  // Get world name if needed
  let worldName = updates.world || "";
  if (!worldName && worldId) {
    const { data: worldData } = await supabase
      .from("worlds")
      .select("name")
      .eq("id", worldId)
      .maybeSingle();
    worldName = worldData?.name || "";
  }

  return {
    id: updatedLog.dream_id,
    date: updatedLog.date,
    wakeTime: updatedLog.wake_time,
    world: worldName,
    timeSystem: updatedLog.time_system as DreamLog["timeSystem"],
    environments: updatedLog.environments || [],
    entities: updates.entities || [],
    threatLevel: updatedLog.threat_level as DreamLog["threatLevel"],
    safetyOverride: updatedLog.safety_override as DreamLog["safetyOverride"],
    exit: updatedLog.exit as DreamLog["exit"],
    notes: updatedLog.notes || undefined,
    createdAt: updatedLog.created_at,
  };
}

export async function deleteDreamLog(dreamId: string): Promise<boolean> {
  const { error } = await supabase
    .from("dream_logs")
    .delete()
    .eq("dream_id", dreamId);

  return !error;
}

// Sleep Logs
export async function getSleepLogs(): Promise<SleepLog[]> {
  const { data, error } = await supabase
    .from("sleep_logs")
    .select("*")
    .order("date", { ascending: false });

  if (error) {
    console.error("Error fetching sleep logs:", error);
    return [];
  }

  return (data || []).map((log) => ({
    id: log.sleep_id,
    date: log.date,
    sleepStart: log.sleep_start,
    wakeTime: log.wake_time,
    totalSleep: { hours: log.total_hours, minutes: log.total_minutes },
    deep: { hours: log.deep_hours, minutes: log.deep_minutes },
    light: { hours: log.light_hours, minutes: log.light_minutes },
    rem: { hours: log.rem_hours, minutes: log.rem_minutes },
    nap: log.nap_minutes
      ? {
          minutes: log.nap_minutes,
          start: log.nap_start || undefined,
          end: log.nap_end || undefined,
        }
      : undefined,
    sleepScore: log.sleep_score || undefined,
    deepContinuityScore: log.deep_continuity_score || undefined,
    createdAt: log.created_at,
  }));
}

export async function addSleepLog(
  log: Omit<SleepLog, "id" | "createdAt">,
): Promise<SleepLog | null> {
  const userId = await getCurrentUserId();
  const { data, error } = await supabase
    .from("sleep_logs")
    .insert({
      sleep_id: "", // Will be generated by trigger
      date: log.date,
      sleep_start: log.sleepStart,
      wake_time: log.wakeTime,
      total_hours: log.totalSleep.hours,
      total_minutes: log.totalSleep.minutes,
      deep_hours: log.deep.hours,
      deep_minutes: log.deep.minutes,
      light_hours: log.light.hours,
      light_minutes: log.light.minutes,
      rem_hours: log.rem.hours,
      rem_minutes: log.rem.minutes,
      nap_minutes: log.nap?.minutes || null,
      nap_start: log.nap?.start || null,
      nap_end: log.nap?.end || null,
      sleep_score: log.sleepScore || null,
      deep_continuity_score: log.deepContinuityScore || null,
      user_id: userId,
    })
    .select()
    .single();

  if (error || !data) {
    console.error("Error adding sleep log:", error);
    return null;
  }

  return {
    id: data.sleep_id,
    date: data.date,
    sleepStart: data.sleep_start,
    wakeTime: data.wake_time,
    totalSleep: { hours: data.total_hours, minutes: data.total_minutes },
    deep: { hours: data.deep_hours, minutes: data.deep_minutes },
    light: { hours: data.light_hours, minutes: data.light_minutes },
    rem: { hours: data.rem_hours, minutes: data.rem_minutes },
    nap: data.nap_minutes
      ? {
          minutes: data.nap_minutes,
          start: data.nap_start || undefined,
          end: data.nap_end || undefined,
        }
      : undefined,
    sleepScore: data.sleep_score || undefined,
    deepContinuityScore: data.deep_continuity_score || undefined,
    createdAt: data.created_at,
  };
}

// Worlds
export async function getWorlds(): Promise<World[]> {
  const { data, error } = await supabase
    .from("worlds")
    .select(
      `
      *,
      dream_logs(dream_id)
    `,
    )
    .order("name");

  if (error) {
    console.error("Error fetching worlds:", error);
    return [];
  }

  return (data || []).map((world) => ({
    id: world.id,
    name: world.name,
    type: world.type as World["type"],
    stability: world.stability,
    description: world.description || undefined,
    dreamIds:
      world.dream_logs?.map((d: { dream_id: string }) => d.dream_id) || [],
  }));
}

export async function addWorld(
  world: Omit<World, "id" | "dreamIds">,
): Promise<World | null> {
  const userId = await getCurrentUserId();
  const { data, error } = await supabase
    .from("worlds")
    .insert({
      name: world.name,
      type: world.type,
      stability: world.stability,
      description: world.description,
      user_id: userId,
    })
    .select()
    .single();

  if (error || !data) {
    console.error("Error adding world:", error);
    return null;
  }

  return {
    id: data.id,
    name: data.name,
    type: data.type as World["type"],
    stability: data.stability,
    description: data.description || undefined,
    dreamIds: [],
  };
}

// Entities
export async function getEntities(): Promise<Entity[]> {
  const { data, error } = await supabase
    .from("entities")
    .select(
      `
      *,
      dream_log_entities(dream_log:dream_logs(dream_id))
    `,
    )
    .order("name");

  if (error) {
    console.error("Error fetching entities:", error);
    return [];
  }

  return (data || []).map((entity) => ({
    id: entity.id,
    name: entity.name,
    role: entity.role as Entity["role"],
    description: entity.description || undefined,
    dreamIds:
      entity.dream_log_entities
        ?.map(
          (dle: { dream_log: { dream_id: string } }) => dle.dream_log?.dream_id,
        )
        .filter(Boolean) || [],
  }));
}

export async function addEntity(
  entity: Omit<Entity, "id" | "dreamIds">,
): Promise<Entity | null> {
  const userId = await getCurrentUserId();
  const { data, error } = await supabase
    .from("entities")
    .insert({
      name: entity.name,
      role: entity.role,
      description: entity.description,
      user_id: userId,
    })
    .select()
    .single();

  if (error || !data) {
    console.error("Error adding entity:", error);
    return null;
  }

  return {
    id: data.id,
    name: data.name,
    role: data.role as Entity["role"],
    description: data.description || undefined,
    dreamIds: [],
  };
}

// System Modules
export async function getModules(): Promise<SystemModule[]> {
  const { data, error } = await supabase
    .from("system_modules")
    .select(
      `
      *,
      dream_log_modules(dream_log:dream_logs(dream_id))
    `,
    )
    .order("name");

  if (error) {
    console.error("Error fetching modules:", error);
    return [];
  }

  return (data || []).map((mod) => ({
    id: mod.id,
    name: mod.name,
    type: mod.type as SystemModule["type"],
    description: mod.description || undefined,
    dreamIds:
      mod.dream_log_modules
        ?.map(
          (dlm: { dream_log: { dream_id: string } }) => dlm.dream_log?.dream_id,
        )
        .filter(Boolean) || [],
  }));
}

// Threats
export async function getThreats(): Promise<ThreatEntry[]> {
  const { data, error } = await supabase
    .from("threats")
    .select(
      `
      *,
      dream_log_threats(dream_log:dream_logs(dream_id))
    `,
    )
    .order("name");

  if (error) {
    console.error("Error fetching threats:", error);
    return [];
  }

  return (data || []).map((threat) => ({
    id: threat.id,
    name: threat.name,
    level: threat.level as ThreatEntry["level"],
    ability: (threat as any).ability || undefined,
    countermeasure: (threat as any).countermeasure || undefined,
    summonMedium: (threat as any).summon_medium || undefined,
    response: threat.response || undefined,
    dreamIds:
      threat.dream_log_threats
        ?.map(
          (dlt: { dream_log: { dream_id: string } }) => dlt.dream_log?.dream_id,
        )
        .filter(Boolean) || [],
  }));
}

// Parse sleep image
export async function parseSleepImage(imageBase64: string): Promise<{
  date_th?: string;
  sleep_start?: string;
  wake_time?: string;
  total_sleep?: { hours: number; minutes: number };
  deep?: { hours: number; minutes: number };
  light?: { hours: number; minutes: number };
  rem?: { hours: number; minutes: number };
  nap?: { minutes: number; start?: string; end?: string };
  sleep_score?: number;
  deep_continuity_score?: number;
  inconsistent?: boolean;
  error?: string;
}> {
  const response = await fetch(
    `${import.meta.env.VITE_SUPABASE_URL}/functions/v1/parse-sleep`,
    {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${import.meta.env.VITE_SUPABASE_PUBLISHABLE_KEY}`,
      },
      body: JSON.stringify({ image: imageBase64 }),
    },
  );

  if (!response.ok) {
    const errorData = await response.json();
    return { error: errorData.error || "Failed to parse image" };
  }

  return response.json();
}

// AI Chat for Librarian
export async function sendAIChat(
  messages: { role: "user" | "assistant"; content: string }[],
  context: Record<string, unknown>,
): Promise<{
  response: string;
  dreamIds: string[];
  matchedWorlds: string[];
  matchedEntities: string[];
  matchedThreats: string[];
  error?: string;
}> {
  const response = await fetch(
    `${import.meta.env.VITE_SUPABASE_URL}/functions/v1/ai-chat`,
    {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${import.meta.env.VITE_SUPABASE_PUBLISHABLE_KEY}`,
      },
      body: JSON.stringify({ messages, context }),
    },
  );

  if (!response.ok) {
    const errorData = await response.json();
    return {
      response: "",
      dreamIds: [],
      matchedWorlds: [],
      matchedEntities: [],
      matchedThreats: [],
      error: errorData.error || "AI error",
    };
  }

  return response.json();
}

// Suggest tags from dream text
export async function suggestTags(
  text: string,
  existingWorlds: string[],
  existingEntities: string[],
  existingEnvironments: string[],
): Promise<{
  world: string | null;
  environments: string[];
  entities: string[];
  threatLevel: number;
  safetyOverride: string;
  exit: string;
  timeSystem: string;
}> {
  const response = await fetch(
    `${import.meta.env.VITE_SUPABASE_URL}/functions/v1/suggest-tags`,
    {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${import.meta.env.VITE_SUPABASE_PUBLISHABLE_KEY}`,
      },
      body: JSON.stringify({
        text,
        existingWorlds,
        existingEntities,
        existingEnvironments,
      }),
    },
  );

  if (!response.ok) {
    return {
      world: null,
      environments: [],
      entities: [],
      threatLevel: 0,
      safetyOverride: "unknown",
      exit: "unknown",
      timeSystem: "unknown",
    };
  }

  return response.json();
}

// Update World
export async function updateWorld(
  id: string,
  updates: Partial<Omit<World, "id" | "dreamIds">>,
): Promise<World | null> {
  const { data, error } = await supabase
    .from("worlds")
    .update({
      name: updates.name,
      type: updates.type,
      stability: updates.stability,
      description: updates.description,
    })
    .eq("id", id)
    .select()
    .single();

  if (error || !data) {
    console.error("Error updating world:", error);
    return null;
  }

  return {
    id: data.id,
    name: data.name,
    type: data.type as World["type"],
    stability: data.stability,
    description: data.description || undefined,
    dreamIds: [],
  };
}

export async function deleteWorld(id: string): Promise<boolean> {
  const { error } = await supabase.from("worlds").delete().eq("id", id);
  return !error;
}

// Update Entity
export async function updateEntity(
  id: string,
  updates: Partial<Omit<Entity, "id" | "dreamIds">>,
): Promise<Entity | null> {
  const { data, error } = await supabase
    .from("entities")
    .update({
      name: updates.name,
      role: updates.role,
      description: updates.description,
    })
    .eq("id", id)
    .select()
    .single();

  if (error || !data) {
    console.error("Error updating entity:", error);
    return null;
  }

  return {
    id: data.id,
    name: data.name,
    role: data.role as Entity["role"],
    description: data.description || undefined,
    dreamIds: [],
  };
}

export async function deleteEntity(id: string): Promise<boolean> {
  const { error } = await supabase.from("entities").delete().eq("id", id);
  return !error;
}

// Add Module
export async function addModule(
  mod: Omit<SystemModule, "id" | "dreamIds">,
): Promise<SystemModule | null> {
  const userId = await getCurrentUserId();
  const { data, error } = await supabase
    .from("system_modules")
    .insert({
      name: mod.name,
      type: mod.type,
      description: mod.description,
      user_id: userId,
    })
    .select()
    .single();

  if (error || !data) {
    console.error("Error adding module:", error);
    return null;
  }

  return {
    id: data.id,
    name: data.name,
    type: data.type as SystemModule["type"],
    description: data.description || undefined,
    dreamIds: [],
  };
}

export async function deleteModule(id: string): Promise<boolean> {
  const { error } = await supabase.from("system_modules").delete().eq("id", id);
  return !error;
}

// Add Threat
export async function addThreat(
  threat: Omit<ThreatEntry, "id" | "dreamIds">,
): Promise<ThreatEntry | null> {
  const userId = await getCurrentUserId();
  const { data, error } = await supabase
    .from("threats")
    .insert({
      name: threat.name,
      level: threat.level,
      ability: (threat as any).ability?.trim() || null,
      countermeasure: (threat as any).countermeasure?.trim() || null,
      summon_medium: (threat as any).summonMedium?.trim() || null,
      response: threat.response,
      user_id: userId,
    } as any)
    .select()
    .single();

  if (error || !data) {
    console.error("Error adding threat:", error);
    return null;
  }

  return {
    id: data.id,
    name: data.name,
    level: data.level as ThreatEntry["level"],
    ability: (data as any).ability || undefined,
    countermeasure: (data as any).countermeasure || undefined,
    summonMedium: (data as any).summon_medium || undefined,
    response: data.response || undefined,
    dreamIds: [],
  };
}

export async function updateThreat(
  id: string,
  updates: Partial<Omit<ThreatEntry, "id" | "dreamIds">>,
): Promise<ThreatEntry | null> {
  const payload = {
    ...(updates.name !== undefined ? { name: updates.name } : {}),
    ...(updates.level !== undefined ? { level: updates.level } : {}),
    ...(updates.ability !== undefined
      ? { ability: updates.ability?.trim() || null }
      : {}),
    ...(updates.countermeasure !== undefined
      ? { countermeasure: updates.countermeasure?.trim() || null }
      : {}),
    ...(updates.summonMedium !== undefined
      ? { summon_medium: updates.summonMedium?.trim() || null }
      : {}),
    ...(updates.response !== undefined
      ? { response: updates.response?.trim() || null }
      : {}),
  };

  const { data, error } = await supabase
    .from("threats")
    .update(payload as any)
    .eq("id", id)
    .select()
    .single();

  if (error || !data) {
    console.error("Error updating threat:", error);
    return null;
  }

  return {
    id: data.id,
    name: data.name,
    level: data.level as ThreatEntry["level"],
    ability: (data as any).ability || undefined,
    countermeasure: (data as any).countermeasure || undefined,
    summonMedium: (data as any).summon_medium || undefined,
    response: data.response || undefined,
    dreamIds: [],
  };
}

export async function deleteThreat(id: string): Promise<boolean> {
  const { error } = await supabase.from("threats").delete().eq("id", id);
  return !error;
}
